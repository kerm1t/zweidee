////////////////////////////
// main.cpp
// - independent render loop
//   - engine.move
//   - engine.render
////////////////////////////


#include "stdafx.h"
#include "resource.h"

#include "zweidee.h"    // draw to 2D buffer
#include "engine.h"	    //   run a 2D game

#include <windows.h>    // Header File For Windows
//#include <windowsx.h>   // GET_X_LPARAM, GET_Y_LPARAM

#define GLEW_STATIC
#include <GL/glew.h>

#include <process.h>    // _beginthread

#define MAX_LOADSTRING 100

// global variables
HINSTANCE        hInst;                         // current instance
TCHAR            szTitle[MAX_LOADSTRING];       // Titelleistentext
TCHAR            szWindowClass[MAX_LOADSTRING]; // Klassenname des Hauptfensters

// forward declaration of functions in thsi code module
ATOM             MyRegisterClass(HINSTANCE hInstance);
BOOL             InitInstance(HINSTANCE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
//INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);

HGLRC            hRC=NULL;                      // Permanent Rendering Context
HDC              hDC=NULL;                      // Private GDI Device Context
HWND             hWnd=NULL;                     // Holds Our Window Handle

zweidee::Engine m_engine;

int win_h;
int win_w;
bool b_WM_resized = false;


dword lasttickcount = 0;
dword accumulatedTimeSinceLastUpdate = 0;

// Fix Timing
// https://gafferongames.com/post/fix_your_timestep/

// OpenGL calls moved to own thread
// s. http://stackoverflow.com/questions/9833852/opengl-game-loop-multithreading
void RenderThread(void *args)
{
  lasttickcount = GetTickCount();
  while (true)
  {
    accumulatedTimeSinceLastUpdate += (GetTickCount() - lasttickcount); // GetTickCount [ms] dword
    lasttickcount = GetTickCount();

    if (accumulatedTimeSinceLastUpdate > 12) // indep. from gfx-card -> update every 12 [ms]
    {
      accumulatedTimeSinceLastUpdate = 0;

//      if (GetAsyncKeyState(VK_SPACE)) m_proj.fire(); // rapid fire :-)
      if (GetAsyncKeyState(VK_UP))    m_engine.up();
      if (GetAsyncKeyState(VK_DOWN))  m_engine.down();
      if (GetAsyncKeyState(VK_LEFT))  m_engine.left();
      if (GetAsyncKeyState(VK_RIGHT)) m_engine.right();

	    m_engine.move();
    }

    if (b_WM_resized)
    {
// 2do: move from engine to zweidee -->
		  m_engine.m_render.ReSizeGLScene(win_w,win_h);
      b_WM_resized = false;
    }

  	m_engine.render(); // render update-rate independent from move() (s. above) 
  }
  _endthread();
}

int APIENTRY _tWinMain(HINSTANCE hInstance,
  HINSTANCE hPrevInstance,
  LPTSTR    lpCmdLine,
  int       nCmdShow)
{
  UNREFERENCED_PARAMETER(hPrevInstance);
  UNREFERENCED_PARAMETER(lpCmdLine);

  MSG msg;
  HACCEL hAccelTable;

  // init global strings
  LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);  // window title etc. see .rc
  LoadString(hInstance, IDC_ZWEIDEE, szWindowClass, MAX_LOADSTRING);
  MyRegisterClass(hInstance);

  // init application
  if (!InitInstance (hInstance, nCmdShow))
  {
    return FALSE;
  }

  RECT rect; 
  if (GetClientRect(hWnd, &rect))
  { 
    win_w = rect.right - rect.left; 
    win_h = rect.bottom - rect.top; 
  }

// 2do: this should be zweidee -->
  m_engine.m_render.width = win_w; // this will size the viewport
  m_engine.m_render.height = win_h;
  hDC = m_engine.m_render.GL_attach_to_DC(hWnd); // <== NeHe    

  glewExperimental = GL_TRUE; // <-- Nutzen?
  glewInit(); // <-- takes a little time

// 2do: this should be zweidee -->
  m_engine.init();	// <-- Textures erst nach glewInit() laden!!
                    // a) data loading + b) data description c) render.Init()
  
  hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_ZWEIDEE));

  _beginthread(RenderThread, 0, 0);

  // main message loop
  while (GetMessage(&msg, NULL, 0, 0))
  {
    wglMakeCurrent(NULL,NULL); // <-- no other access to OpenGL here!! --> only in RenderThread 

    if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
    {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    }

    // --> rendering moved to RenderThread, otherwise no autonomous object-movement possible
  }

  return (int) msg.wParam;
}

// autogenerated: register window class (mandatory)
ATOM MyRegisterClass(HINSTANCE hInstance)
{
  WNDCLASSEX wcex;

  wcex.cbSize = sizeof(WNDCLASSEX);

  wcex.style			= CS_HREDRAW | CS_VREDRAW;
  wcex.lpfnWndProc	= WndProc;
  wcex.cbClsExtra		= 0;
  wcex.cbWndExtra		= 0;
  wcex.hInstance		= hInstance;
  wcex.hIcon			= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ZWEIDEE));
  wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
  wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
  wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_ZWEIDEE);
  wcex.lpszClassName	= szWindowClass;
  wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

  return RegisterClassEx(&wcex);
}

// autogenerated: save instance handle and create main window
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
  hInst = hInstance; // store instance handle
  // Nonsense:
  // one is the viewport, i.e. window size
  // the other is the internal texture size, i.e. the game playfield 
//#define galaga
//#ifdef frogger
  int w = 600; // frogger: 600, other: 800
  int h = 800;
//#endif
//#ifdef galaga
//  int w = 512;
//  int h = 512;
//#endif
  // center on screen
  RECT rect;
  GetClientRect(GetDesktopWindow(), &rect);
  int x = (rect.right - w) / 2;
  int y = (rect.bottom -h) / 2;
  // center on screen
  hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, x, y, w, h, NULL, NULL, hInstance, NULL);

  if (!hWnd)
  {
    return FALSE;
  }

  ShowWindow(hWnd, nCmdShow);
  UpdateWindow(hWnd);

  return TRUE;
}

// autogenerated: process main window's messages
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  int wmId, wmEvent;

  switch (message)
  {
  case WM_MOUSEWHEEL:
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms645617(v=vs.85).aspx
    break;
  case WM_MOUSEMOVE:
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms645616(v=vs.85).aspx
    break;
  case WM_COMMAND:
    wmId    = LOWORD(wParam);
    wmEvent = HIWORD(wParam);
    // process menu choice
    switch (wmId)
    {
    case IDM_ABOUT:
      DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, zweidee::About);
      break;
    case IDM_EXIT:
      DestroyWindow(hWnd);
      break;
    default:
      return DefWindowProc(hWnd, message, wParam, lParam);
    }
    break;
 //	case WM_PAINT:
 // ... painting by OpenGL
  case WM_KEYDOWN:

    switch (wParam)
    {
    case 32: // Space
      m_engine.fire(); // single fire
      break;
    case 37: // ARROW-LEFT
      break;
    case 39: // ARROW-RIGHT
      break;
    case 79: // O >> Step
      m_engine.bStep = true;
      break;
    case 80: // P >> Pause ON/OFF
      m_engine.bPause = !(m_engine.bPause);
      break;
    case 87: // W
      break;
    case 65: // A
      break;
    case 83: // S
      break;
    case 68: // D
      break;
    }
    break;
  case WM_SIZE:
    win_w = LOWORD(lParam);
    win_h = HIWORD(lParam);
    // resize --> in the thread now, as from here no access to OpenGL-context
    b_WM_resized = true;
    break;
  case WM_DESTROY:
    PostQuitMessage(0);
    break;
  default:
    return DefWindowProc(hWnd, message, wParam, lParam);
  }
  return 0;
}
/*
// Meldungshandler für Infofeld.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  UNREFERENCED_PARAMETER(lParam);
  switch (message)
  {
  case WM_INITDIALOG:
    return (INT_PTR)TRUE;

  case WM_COMMAND:
    if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
    {
      EndDialog(hDlg, LOWORD(wParam));
      return (INT_PTR)TRUE;
    }
    break;
  }
  return (INT_PTR)FALSE;
}
*/
